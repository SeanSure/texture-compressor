<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Texture handler</title>
	<style>
		body, html {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			background: #fefefe;
		}

		img {
			width: 100%;
			max-width: 512;
		}
	</style>
</head>
<body>
    <div id="app">
		<section class="s3tc">
			<h3>S3TC</h3>
			<div class="gallery-item" id="DXT1">DXT1</div>
			<div class="gallery-item" id="DXT3">DXT3</div>
			<div class="gallery-item" id="DXT5">DXT5</div>
		</section>

		<section class="etc1">
			<h3>ETC1</h3>
			<div class="gallery-item" id="ETC1_RGB">ETC1_RGB</div>
		</section>

		<section class="etc2">
			<h3>ETC2</h3>
			<div class="gallery-item" id="ETC2_RGB">ETC2_RGB</div>
			<div class="gallery-item" id="ETC2_RGBA">ETC2_RGBA</div>
		</section>

		<section class="pvrtc">
			<h3>PVRTC</h3>
			<div class="gallery-item" id="PVRTC_RGB_2BPP">PVRTC_RGB_2BPP</div>
			<div class="gallery-item" id="PVRTC_RGBA_2BPP">PVRTC_RGBA_2BPP</div>
			<div class="gallery-item" id="PVRTC_RGB_4BPP">PVRTC_RGB_4BPP</div>
			<div class="gallery-item" id="PVRTC_RGBA_4BPP">PVRTC_RGB_4BPP</div>
		</section>
	</div>

    <script>
		// Parsers
		// -------
		function parseDDS(buffer) {
			// Supports DXT1, DXT3, DXT5
			// WEBGL_compressed_texture_s3tc
			// WEBGL_compressed_texture_s3tc_srgb

			// DDS
			const DDS_HEADER_MAGIC = 0;
			const DDS_HEADER_SIZE = 1;
			const DDS_HEADER_FLAGS = 2;
			const DDS_HEADER_HEIGHT = 3;
			const DDS_HEADER_WIDTH = 4;
			const DDS_HEADER_MIPMAPCOUNT = 7;
			const DDS_HEADER_LENGTH = 31 // 32 bits
			const DDSD_MIPMAPCOUNT = 0x20000;
			const DDS_MAGIC = 0x20534444;
			const DDS_PIXEL_FORMAT_FOURCC = 0x4;
			const DDS_HEADER_PIXEL_FORMAT_FLAGS = 20;
			const DDS_HEADER_PIXEL_FORMAT_FOURCC = 21;

			// ENUM S3TC
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
			const COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
			const COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
			const COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

			// S3TC
			const FOURCC_TYPE_DXT1 = 827611204;
			const FOURCC_TYPE_DXT3 = 861165636;
			const FOURCC_TYPE_DXT5 = 894720068;

			const header = new Int32Array(buffer, 0, DDS_HEADER_LENGTH);

			if (header[DDS_HEADER_MAGIC] !== DDS_MAGIC) {
				console.warn(`Invalid magic number: ${header[DDS_HEADER_MAGIC]} in DDS header`);
			}

			if (!header[DDS_HEADER_PIXEL_FORMAT_FLAGS] & DDS_PIXEL_FORMAT_FOURCC) {
				console.warn('Unsupported format, must contain a FourCC code');
			}

			const fileType = header[DDS_HEADER_PIXEL_FORMAT_FOURCC];

			let format;
			let type;

			switch(fileType) {
				case FOURCC_TYPE_DXT1:
					format = COMPRESSED_RGB_S3TC_DXT1_EXT;
					type = 'DXT1';
					break;
				case FOURCC_TYPE_DXT3:
					format = COMPRESSED_RGBA_S3TC_DXT3_EXT;
					type = 'DXT3';
					break;
				case FOURCC_TYPE_DXT5:
					format = COMPRESSED_RGBA_S3TC_DXT5_EXT;
					type = 'DXT5';
					break;
				default:
					console.warn(`${fileType} was not recognized as a valid type`);
					break;
			}

			const mipMapLevels = (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) ? Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]) : 1;
			const width = header[DDS_HEADER_WIDTH];
			const height = header[DDS_HEADER_HEIGHT];
			const dataOffset = header[DDS_HEADER_SIZE] + 4;
			const data = new Uint8Array(buffer, dataOffset);

			return {
				mipMapLevels,
				width,
				height,
				format,
				type,
				data,
			}
		}

		function parsePVR(buffer) {
			// Supports ETC1, ETC2, PVRTC1
			// WEBGL_compressed_texture_etc1
			// WEBGL_compressed_texture_etc
			// WEBGL_compressed_texture_pvrtc

			// PVR
			const PVR_HEADER_LENGTH = 13;
			const PVR_MAGIC = 0x03525650;
			const PVR_HEADER_MAGIC = 0;
			const PVR_HEADER_FORMAT = 2;
			const PVR_HEADER_HEIGHT = 6;
			const PVR_HEADER_WIDTH = 7;
			const PVR_HEADER_MIPMAPCOUNT = 11;
			const PVR_HEADER_METADATA = 12;

			// ENUM ETC1
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/
			const COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;

			// ENUM ETC2
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
			const COMPRESSED_RGB8_ETC2 = 0x9274;
			const COMPRESSED_RGBA8_ETC2_EAC = 0x9278;

			// ENUM PVRTC
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
			const COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
			const COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
			const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
			const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;

			// ETC1
			const ETC1 = 6;

			// ETC2
			const ETC2_RGB = 22;
			const ETC2_RGBA = 23;

			// PVRTC
			const PVRTC_2BPP_RGB = 0;
			const PVRTC_2BPP_RGBA = 1;
			const PVRTC_4BPP_RGB = 2;
			const PVRTC_4BPP_RGBA = 3;

			const header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);

			if (header[PVR_HEADER_MAGIC] !== PVR_MAGIC) {
				console.warn(`Invalid magic number: ${header[PVR_HEADER_MAGIC]} in PVR header`);
			}

			const fileType = header[PVR_HEADER_FORMAT];

			let format;
			let type;

			switch(fileType) {
				// ETC1
				case ETC1:
					format = COMPRESSED_RGB_ETC1_WEBGL;
					type = 'ETC1_RGB';
					break;

				// ETC2
				case ETC2_RGB:
					format = COMPRESSED_RGB8_ETC2;
					type = 'ETC2_RGB';
					break;

				case ETC2_RGBA:
					format = COMPRESSED_RGBA8_ETC2_EAC;
					type = 'ETC2_RGBA';
					break;

				// PVRTC
				case PVRTC_2BPP_RGB:
					format = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					type = 'PVRTC_RGB_2BPP';
					break;

				case PVRTC_2BPP_RGBA:
					format = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					type = 'PVRTC_RGBA_2BPP';
					break;

				case PVRTC_4BPP_RGB:
					format = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					type = 'PVRTC_RGB_4BPP';
					break;

				case PVRTC_4BPP_RGBA:
					format = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					type = 'PVRTC_RGBA_4BPP';
					break;

				default:
					console.warn(`${fileType} was not recognized as a valid type`);
					break;
			}

			const mipMapLevels = Math.max(1, header[PVR_HEADER_MIPMAPCOUNT])
			const width = header[PVR_HEADER_WIDTH];
			const height = header[PVR_HEADER_HEIGHT];
			const dataOffset = header[PVR_HEADER_METADATA] + 52;
			const data = new Uint8Array(buffer, dataOffset);

			return {
				mipMapLevels,
				width,
				height,
				format,
				type,
				data,
			}
		}

		// Utilities
		// ---------
		function fileLoader(url, responseType = '') {
			return new Promise((resolve, reject) => {
				const request = new XMLHttpRequest();

				request.responseType = responseType || '';
				request.onreadystatechange = () => {
					if (request.readyState !== 4) return;

					if (request.readyState === 4 && request.status === 200) {
						resolve(request.response, request.status);
					} else {
						reject(request.status);
					}
				};

				request.open('GET', url, true);
				request.send();
			});
		}

        function parseBinary(filename, bin) {
			const containerType = filename.split('.').pop();

			let result;

			if (containerType === 'dds') {
				result = parseDDS(bin);
			} else if (containerType === 'pvr') {
				result = parsePVR(bin);
			} else {
				console.error('Filename should have a .dds or .pvr extension');
			}

            return result;
		}

        function loadBinary(filename) {
            return new Promise((resolve, reject) => {
                fileLoader(filename, 'arraybuffer')
                    .then((bin) => {
                        resolve(parseBinary(filename, bin));
                    })
                    .catch((error) => {
                        reject(console.warn(error));
                    });
            });
        }

		// WebGL utilities
		// ---------------
		function getExtension(extension) {

		}

		// Initialize
		// ----------
		function initialize() {
			const app = document.getElementById('app');

			const result = Promise.all([
				loadBinary('./example/example-dxt1.dds'),
				loadBinary('./example/example-dxt3.dds'),
				loadBinary('./example/example-dxt5.dds'),
				loadBinary('./example/example-etc1.pvr'),
				loadBinary('./example/example-etc2.pvr'),
				loadBinary('./example/example-pvrtc1.pvr'),
			]);

			result
				.then((data) => {
					data.map((file) => {
						const element = document.getElementById(`${file.type}`);
						const canvas = document.createElement('canvas');
						canvas.width = file.width;
						canvas.height = file.height;
						const gl = canvas.getContext('webgl');
						const extension = (
							gl.getExtension('WEBGL_compressed_texture_s3tc') ||
							gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
							gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
						);
						element.appendChild(canvas);

						// const texture = gl.createTexture();
						// gl.bindTexture(gl.TEXTURE_2D, texture);
						// gl.compressedTexImage2D(gl.TEXTURE_2D, 0, file.format, 512, 512, 0, file.data);
						// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
						// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					});
				});
		}

		initialize();
    </script>
</body>
</html>
