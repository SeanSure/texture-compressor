<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Texture handler</title>
</head>
<body>
    <pre id="app"></pre>

    <script>
		function fileLoader(url, responseType = '') {
			return new Promise((resolve, reject) => {
				const request = new XMLHttpRequest();

				request.responseType = responseType || '';
				request.onreadystatechange = () => {
					if (request.readyState !== 4) return;

					if (request.readyState === 4 && request.status === 200) {
						resolve(request.response, request.status);
					} else {
						reject(request.status);
					}
				};

				request.open('GET', url, true);
				request.send();
			});
		}

		function parsePVR(buffer) {
			// Supports ETC1, ETC2, PVRTC1
			// WEBGL_compressed_texture_etc1
			// WEBGL_compressed_texture_etc
			// WEBGL_compressed_texture_pvrtc

			// PVR
			const PVR_HEADER_LENGTH = 13;
			const PVR_MAGIC = 0x03525650;
			const PVR_HEADER_MAGIC = 0;
			const PVR_HEADER_FORMAT = 2;
			const PVR_HEADER_HEIGHT = 6;
			const PVR_HEADER_WIDTH = 7;
			const PVR_HEADER_MIPMAPCOUNT = 11;
			const PVR_HEADER_METADATA = 12;

			// ENUM ETC1
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/
			const COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;

			// ENUM ETC2
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
			const COMPRESSED_RGB8_ETC2 = 0x9274;
			const COMPRESSED_RGBA8_ETC2_EAC = 0x9278;

			// ENUM PVRTC
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
			const COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
			const COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
			const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
			const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;

			// ETC1
			const ETC1 = 6;

			// ETC2
			const ETC2_RGB = 22;
			const ETC2_RGBA = 23;

			// PVRTC
			const PVRTC_2BPP_RGB = 0;
			const PVRTC_2BPP_RGBA = 1;
			const PVRTC_4BPP_RGB = 2;
			const PVRTC_4BPP_RGBA = 3;

			const header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);

			if (header[PVR_HEADER_MAGIC] !== PVR_MAGIC) {
				console.warn(`Invalid magic number: ${header[PVR_HEADER_MAGIC]} in PVR header`);
			}

			const fileType = header[PVR_HEADER_FORMAT];

			let format;

			switch(fileType) {
				// ETC1
				case ETC1:
					format = COMPRESSED_RGB_ETC1_WEBGL;
					break;

				// ETC2
				case ETC2_RGB:
					format = COMPRESSED_RGB8_ETC2;
					break;

				case ETC2_RGBA:
					format = COMPRESSED_RGBA8_ETC2_EAC;
					break;

				// PVRTC
				case PVRTC_2BPP_RGB:
					format = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					break;

				case PVRTC_2BPP_RGBA:
					format = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					break;

				case PVRTC_4BPP_RGB:
					format = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					break;

				case PVRTC_4BPP_RGBA:
					format = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					break;

				default:
					console.warn(`${fileType} was not recognized as a valid type`);
					break;
			}

			const mipMapLevels = Math.max(1, header[PVR_HEADER_MIPMAPCOUNT])
			const width = header[PVR_HEADER_WIDTH];
			const height = header[PVR_HEADER_HEIGHT];
			const dataOffset = header[PVR_HEADER_METADATA] + 52;
			const data = new Uint8Array(buffer, dataOffset);

			return {
				mipMapLevels,
				width,
				height,
				format,
				data,
			}
		}

		function parseDDS(buffer) {
			// Supports DXT1, DXT3, DXT5
			// WEBGL_compressed_texture_s3tc
			// WEBGL_compressed_texture_s3tc_srgb

			// DDS
			const DDS_HEADER_MAGIC = 0;
			const DDS_HEADER_SIZE = 1;
			const DDS_HEADER_FLAGS = 2;
			const DDS_HEADER_HEIGHT = 3;
			const DDS_HEADER_WIDTH = 4;
			const DDS_HEADER_MIPMAPCOUNT = 7;
			const DDS_HEADER_LENGTH = 31 // 32 bits
			const DDSD_MIPMAPCOUNT = 0x20000;
			const DDS_MAGIC = 0x20534444;
			const DDS_PIXEL_FORMAT_FOURCC = 0x4;
			const DDS_HEADER_PIXEL_FORMAT_FLAGS = 20;
			const DDS_HEADER_PIXEL_FORMAT_FOURCC = 21;

			// ENUM S3TC
			// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
			const COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
			const COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
			const COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

			// S3TC
			const FOURCC_TYPE_DXT1 = 827611204;
			const FOURCC_TYPE_DXT3 = 861165636;
			const FOURCC_TYPE_DXT5 = 894720068;

			const header = new Int32Array(buffer, 0, DDS_HEADER_LENGTH);

			if (header[DDS_HEADER_MAGIC] !== DDS_MAGIC) {
				console.warn(`Invalid magic number: ${header[DDS_HEADER_MAGIC]} in DDS header`);
			}

			if (!header[DDS_HEADER_PIXEL_FORMAT_FLAGS] & DDS_PIXEL_FORMAT_FOURCC) {
				console.warn('Unsupported format, must contain a FourCC code');
			}

			const fileType = header[DDS_HEADER_PIXEL_FORMAT_FOURCC];

			let format;

			switch(fileType) {
				case FOURCC_TYPE_DXT1:
					format = COMPRESSED_RGB_S3TC_DXT1_EXT;
					break;
				case FOURCC_TYPE_DXT3:
					format = COMPRESSED_RGBA_S3TC_DXT3_EXT;
					break;
				case FOURCC_TYPE_DXT5:
					format = COMPRESSED_RGBA_S3TC_DXT5_EXT;
					break;
				default:
					console.warn(`${fileType} was not recognized as a valid type`);
					break;
			}

			const mipMapLevels = (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) ? Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]) : 1;
			const width = header[DDS_HEADER_WIDTH];
			const height = header[DDS_HEADER_HEIGHT];
			const dataOffset = header[DDS_HEADER_SIZE] + 4;
			const data = new Uint8Array(buffer, dataOffset);

			return {
				mipMapLevels,
				width,
				height,
				format,
				data,
			}
		}

        function parseBinary(filename, bin) {
			const containerType = filename.split('.').pop();

			let result;

			if (containerType === 'dds') {
				result = parseDDS(bin);
			} else if (containerType === 'pvr') {
				result = parsePVR(bin);
			} else {
				console.error('Filename should have a .dds or .pvr extension');
			}

            return result;
		}

        function loadBinary(filename) {
            return new Promise((resolve, reject) => {
                fileLoader(filename, 'arraybuffer')
                    .then((bin) => {
                        resolve(parseBinary(filename, bin));
                    })
                    .catch((error) => {
                        reject(console.warn(error));
                    });
            });
        }

		const app = document.getElementById('app');

        const result = Promise.all([
			loadBinary('./example/example-dxt1.dds'),
			loadBinary('./example/example-dxt3.dds'),
			loadBinary('./example/example-dxt5.dds'),
			loadBinary('./example/example-etc1.pvr'),
			loadBinary('./example/example-etc2.pvr'),
			loadBinary('./example/example-pvrtc1.pvr'),
		]);

        result
            .then((data) => {
                console.log(...data);
                // app.appendChild(document.createTextNode(JSON.stringify(data, null, 2)));
            });
    </script>
</body>
</html>
